# MIPS Assembly Simulator - GUI 使用指南

**版本：Dear ImGui Version 2.0 - 完整執行功能版**  
**更新日期：2025年7月31日**  
**適用於：Windows/Linux 平台**

## 🎯 簡介

MIPS Assembly Simulator GUI 是一個教育用途的 MIPS 處理器模擬器，採用 Dear ImGui 框架建構的現代化圖形使用者介面。本工具專為學習 MIPS 彙編語言和電腦架構而設計，提供即時的視覺化管線執行過程。

**✨ 新功能亮點**：
- ✅ 完整 MIPS 程式執行能力
- ✅ 單步調試功能
- ✅ 即時寄存器與記憶體監控
- ✅ 內建示例程式載入
- ✅ 完整系統調用支援

## 🚀 啟動應用程式

### 系統需求
- **作業系統**：Windows 10+ 或 Linux
- **顯示卡**：支援 OpenGL 3.3+ 
- **記憶體**：最少 256MB RAM
- **存儲空間**：50MB 可用空間

### 執行方式

```powershell
# 啟動 GUI 模式（預設）
.\build\src\mips-sim-gui.exe

# 無頭模式（僅用於自動化測試）
.\build\src\mips-sim-gui.exe --headless
```

## 🖥️ 介面概覽

### 主視窗佈局
```
┌─────────────────────────────────────────────────────────┐
│ [檔案] [檢視] [執行] [說明]                    ← 主選單列  │
├─────────────────────────────────────────────────────────┤
│ [▶️執行] [👟單步] [🔄重設] [⚙️管線模式]        ← 工具列    │
├─────────────────────────────────────────────────────────┤
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │
│ │   代碼編輯器   │ │  寄存器檢視器  │ │  記憶體檢視器  │        │
│ │             │ │             │ │             │        │
│ └─────────────┘ └─────────────┘ └─────────────┘        │
│ ┌─────────────┐ ┌─────────────────────────────┐        │
│ │  管線檢視器   │ │        控制台輸出          │        │
│ │             │ │                             │        │
│ └─────────────┘ └─────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
```

## 📚 功能模組詳細說明

### 1. 主選單列功能

#### 📁 檔案選單
- **新建** (Ctrl+N)：清除當前程式碼，開始新專案
- **開啟** (Ctrl+O)：載入 `.asm` 檔案（未來功能）
- **儲存** (Ctrl+S)：儲存當前程式碼（未來功能）
- **匯出**：匯出執行結果（未來功能）
- **結束** (Alt+F4)：關閉應用程式

#### 👁️ 檢視選單
- **代碼編輯器**：顯示/隱藏程式碼編輯視窗
- **寄存器檢視器**：顯示/隱藏寄存器狀態視窗
- **記憶體檢視器**：顯示/隱藏記憶體內容視窗
- **管線檢視器**：顯示/隱藏管線狀態視窗
- **控制台輸出**：顯示/隱藏輸出訊息視窗
- **重設佈局**：恢復預設視窗排列

#### ▶️ 執行選單
- **執行程式** (F5)：編譯並執行整個程式
- **單步執行** (F8)：執行一個指令周期
- **重設模擬器** (F9)：重設所有狀態到初始值
- **管線模式**：切換單週期/管線執行模式
- **暫停執行** (F6)：暫停當前執行（未來功能）

#### ❓ 說明選單
- **使用說明**：顯示簡易使用指南
- **關於**：應用程式版本和開發資訊
- **快捷鍵**：顯示所有鍵盤快捷鍵

## 🎮 程式執行操作指南

### 執行模式

#### 1. 完整執行模式 ▶️
```
使用時機：程式除錯完成，想查看最終結果
操作方式：點擊「Execute」按鈕或按 F5
執行特性：
- 自動執行直到程式結束或達到最大週期數 (1000)
- 即時更新寄存器和記憶體顯示
- 顯示系統調用輸出結果
- 自動檢測無限迴圈並終止
```

#### 2. 單步執行模式 👟
```
使用時機：程式除錯、學習指令執行過程
操作方式：點擊「Step」按鈕或按 F10
執行特性：
- 每次只執行一個指令週期
- 詳細顯示每步的暫存器變化
- 顯示 PC (程式計數器) 變化
- 適合學習和除錯
```

#### 3. 重設功能 🔄
```
使用時機：重新執行程式、清除狀態
操作方式：點擊「Reset」按鈕或按 Ctrl+R
重設內容：
- 所有寄存器歸零（除了 $zero 保持 0）
- 程式計數器歸零
- 記憶體內容保持（設計選擇）
- 清除控制台輸出
```

### 載入示例程式 📋

#### 快速開始功能
```
位置：File > Load Demo Program
內容：預設的算術運算示例
包含功能：
- 基本加法和減法運算
- 記憶體載入和儲存操作
- 系統調用演示
- 完整的程式終止流程
```

#### 示例程式解析
```mips
# 載入測試數據
addi $t0, $zero, 15     # $t0 = 15
addi $t1, $zero, 25     # $t1 = 25

# 執行算術運算
add $t2, $t0, $t1       # $t2 = 15 + 25 = 40
sub $t3, $t1, $t0       # $t3 = 25 - 15 = 10

# 記憶體操作
sw $t2, 0($zero)        # 儲存 40 到記憶體地址 0
sw $t3, 4($zero)        # 儲存 10 到記憶體地址 4

# 列印結果
addi $v0, $zero, 1      # print_int 系統調用
add $a0, $zero, $t2     # 移動結果到參數寄存器
syscall                 # 執行系統調用

# 程式終止
addi $v0, $zero, 10     # exit 系統調用
syscall
```

### 2. 代碼編輯器 📝

#### 基本功能
- **多行編輯**：支援最多 8192 字元的程式碼
- **基本編輯操作**：
  - 複製：Ctrl+C
  - 貼上：Ctrl+V
  - 剪下：Ctrl+X
  - 全選：Ctrl+A
  - 復原：Ctrl+Z

#### 支援的 MIPS 指令
```assembly
# R型指令
add $rd, $rs, $rt     # 加法
sub $rd, $rs, $rt     # 減法

# I型指令  
addi $rt, $rs, imm    # 立即值加法
lw $rt, offset($rs)   # 載入字
sw $rt, offset($rs)   # 儲存字
beq $rs, $rt, label   # 相等分支

# J型指令
j label               # 無條件跳躍

# 系統調用
syscall               # 系統調用
```

#### 程式範例
```assembly
# 範例：計算 1+2 並印出結果
addi $t0, $zero, 1    # $t0 = 1
addi $t1, $zero, 2    # $t1 = 2  
add $a0, $t0, $t1     # $a0 = $t0 + $t1 = 3
addi $v0, $zero, 1    # $v0 = 1 (print_int)
syscall               # 印出 $a0 的值
addi $v0, $zero, 10   # $v0 = 10 (exit)
syscall               # 結束程式
```

### 3. 寄存器檢視器 📊

#### 顯示格式
```
寄存器名稱  | 編號 | 十進位值 | 十六進位值
$zero      | $0   |    0     |  0x00000000
$at        | $1   |   42     |  0x0000002A
$v0        | $2   |    1     |  0x00000001
$v1        | $3   |    0     |  0x00000000
...
```

#### 重要寄存器說明
- **$zero ($0)**：永久為 0，無法修改
- **$at ($1)**：組譯器保留暫存器
- **$v0-$v1 ($2-$3)**：函式回傳值
- **$a0-$a3 ($4-$7)**：函式參數
- **$t0-$t9 ($8-$15, $24-$25)**：暫存器
- **$s0-$s7 ($16-$23)**：保存暫存器
- **$gp ($28)**：全域指標
- **$sp ($29)**：堆疊指標
- **$fp ($30)**：框架指標
- **$ra ($31)**：回傳位址

### 4. 記憶體檢視器 🧠

#### 顯示格式
```
位址      | +0 +1 +2 +3 | +4 +5 +6 +7 | +8 +9 +A +B | +C +D +E +F
0x00000000| 00 00 00 00 | 00 00 00 00 | 00 00 00 00 | 00 00 00 00
0x00000010| 00 00 00 01 | 00 00 00 02 | 00 00 00 03 | 00 00 00 00
...
```

#### 控制選項
- **起始位址**：設定檢視的記憶體起始位置
- **每行位元組數**：調整每行顯示的位元組數量（8, 16, 32）
- **格式選擇**：十六進位/十進位/ASCII 顯示

#### 記憶體特性
- **大小**：4KB (4096 bytes)
- **對齊**：字對齊 (4-byte alignment)
- **位址範圍**：0x00000000 - 0x00000FFF
- **初始狀態**：全部為零

### 5. 管線檢視器 ⚙️

#### 5階段管線顯示
```
階段 | 指令內容                    | 狀態
IF   | lw $t0, 0($s0)             | 正常
ID   | add $t1, $t0, $t2          | 正常  
EX   | sw $t1, 4($s0)             | 正常
MEM  | beq $t0, $t1, loop         | 正常
WB   | addi $t2, $t2, 1           | 正常
```

#### 管線狀態指示
- **正常**：綠色，正常執行
- **暫停**：黃色，等待相依性解決
- **清空**：紅色，分支預測錯誤清空
- **空泡**：灰色，管線氣泡

#### 模式切換
- **單週期模式**：每個指令完整執行後才進行下一個
- **管線模式**：5個指令可同時在不同階段執行

### 6. 控制台輸出 💬

#### 輸出類型
- **系統調用輸出**：
  ```
  [SYSCALL] print_int: 42
  [SYSCALL] print_string: Hello World
  [SYSCALL] read_int: (等待輸入)
  [SYSCALL] exit: Program terminated
  ```

- **錯誤訊息**：
  ```
  [ERROR] Unknown instruction at PC: 0x00000010
  [ERROR] Memory access violation at address: 0x00001000
  [WARNING] Pipeline stall detected
  ```

- **執行狀態**：
  ```
  [INFO] Program loaded: 12 instructions
  [INFO] Execution started in pipeline mode
  [INFO] Execution completed: 25 cycles
  ```

#### 控制功能
- **清除輸出**：清空所有輸出歷史
- **自動滾動**：自動捲動到最新輸出
- **複製內容**：選擇並複製輸出內容

## ⌨️ 鍵盤快捷鍵

### 通用快捷鍵
- **Ctrl+N**：新建程式
- **Ctrl+O**：開啟檔案
- **Ctrl+S**：儲存檔案
- **Ctrl+Q**：結束應用程式

### 執行控制
- **F5**：執行程式
- **F8**：單步執行
- **F9**：重設模擬器
- **F6**：暫停/繼續執行

### 檢視控制
- **F1**：顯示/隱藏代碼編輯器
- **F2**：顯示/隱藏寄存器檢視器
- **F3**：顯示/隱藏記憶體檢視器
- **F4**：顯示/隱藏管線檢視器
- **F10**：顯示/隱藏控制台輸出

## 🎓 學習建議與最佳實踐

### 初學者指南
1. **從簡單開始**：先嘗試單一指令，觀察寄存器變化
2. **使用單步執行**：逐步執行，理解每個指令的作用
3. **觀察管線**：比較單週期與管線模式的差異
4. **練習系統調用**：學習輸入輸出操作

### 進階使用技巧
1. **管線危機觀察**：故意製造資料相依性，觀察暫停現象
2. **分支預測分析**：使用條件分支，觀察管線行為
3. **記憶體操作練習**：練習載入/儲存指令的記憶體存取
4. **程式最佳化**：嘗試減少管線暫停，提高執行效率

### 常見問題解決

#### Q: 程式無法執行怎麼辦？
A: 檢查以下項目：
- 確認所有指令語法正確
- 檢查是否有未定義的標籤
- 確認程式有適當的結束指令 (exit syscall)

#### Q: 管線檢視器顯示暫停怎麼辦？
A: 這是正常現象，表示存在資料相依性：
- 觀察哪些寄存器造成相依性
- 嘗試重新排列指令減少相依性
- 這是學習管線設計的重要概念

#### Q: 記憶體存取錯誤怎麼解決？
A: 檢查記憶體存取：
- 確認位址在有效範圍內 (0x0000-0x0FFF)
- 檢查字對齊要求 (位址必須是 4 的倍數)
- 確認載入前已正確儲存資料

## 🧪 完整測試案例與驗證指南

### 測試檔案位置: `asmtest/` 目錄

#### 1. GUI 演示程式 (`gui_demo_test.asm`)
**目的**: 展示 GUI 的完整功能和基本 MIPS 操作

**程式內容**:
```mips
# 載入測試數據
addi $t0, $zero, 15     # $t0 = 15
addi $t1, $zero, 25     # $t1 = 25

# 算術運算
add $t2, $t0, $t1       # $t2 = 15 + 25 = 40
sub $t3, $t1, $t0       # $t3 = 25 - 15 = 10

# 記憶體操作
sw $t2, 0($zero)        # 儲存 40 到記憶體地址 0
sw $t3, 4($zero)        # 儲存 10 到記憶體地址 4

# 從記憶體載入
lw $s0, 0($zero)        # 載入 40 到 $s0
lw $s1, 4($zero)        # 載入 10 到 $s1

# 列印結果
addi $v0, $zero, 1      # print_int 系統調用
add $a0, $zero, $s0     # 列印第一個結果 (40)
syscall
add $a0, $zero, $s1     # 列印第二個結果 (10)
syscall

# 程式終止
addi $v0, $zero, 10     # exit 系統調用
syscall
```

**預期執行結果**:
- **寄存器狀態**:
  - `$t0 = 15 (0x0000000F)`
  - `$t1 = 25 (0x00000019)`
  - `$t2 = 40 (0x00000028)`
  - `$t3 = 10 (0x0000000A)`
  - `$s0 = 40 (0x00000028)`
  - `$s1 = 10 (0x0000000A)`
- **記憶體內容**:
  - `Memory[0x0000] = 40 (0x00000028)`
  - `Memory[0x0004] = 10 (0x0000000A)`
- **控制台輸出**: `4010`

**驗證步驟**:
1. 載入此程式到 GUI
2. 點擊 Execute 或使用 Step 模式
3. 檢查寄存器檢視器中的數值
4. 檢查記憶體檢視器顯示的內容
5. 確認控制台輸出為 "4010"

#### 2. 系統調用演示 (`demo_syscalls.asm`)
**目的**: 測試所有支援的系統調用功能

**測試的系統調用**:
- `syscall 1`: print_int (列印整數)
- `syscall 4`: print_string (列印字串)
- `syscall 5`: read_int (讀取整數)
- `syscall 10`: exit (程式終止)

**互動測試流程**:
1. 程式會先列印數字 42
2. 等待用戶輸入一個整數
3. 程式讀取並處理輸入
4. 正常終止

#### 3. 控制流程測試 (`test_control.asm`)
**目的**: 驗證分支和跳躍指令

**測試場景**:
```mips
# 測試相等分支
addi $t0, $zero, 5
addi $t1, $zero, 5
beq $t0, $t1, equal     # 應該會跳轉
addi $t2, $zero, 99     # 這行應該被跳過
equal:
addi $t2, $zero, 42     # $t2 應該是 42，不是 99

# 測試無條件跳躍
j end
addi $t3, $zero, 88     # 這行應該被跳過
end:
addi $t3, $zero, 77     # $t3 應該是 77
```

**預期結果**:
- `$t2 = 42` (證明分支正確執行)
- `$t3 = 77` (證明跳躍正確執行)

#### 4. 記憶體操作測試 (`test_memory.asm`)
**目的**: 驗證記憶體載入和儲存指令

**測試內容**:
- 不同偏移量的記憶體存取
- 字對齊驗證
- 資料完整性檢查

#### 5. 立即數運算測試 (`test_addi.asm`)
**目的**: 測試立即數算術指令

**測試場景**:
- 正數立即數加法
- 負數立即數加法 (二補數)
- 邊界值測試

### 🔍 完整功能驗證清單

#### ✅ 核心 MIPS 指令驗證
- [ ] `ADD` - R型加法指令
- [ ] `SUB` - R型減法指令  
- [ ] `ADDI` - I型立即數加法
- [ ] `LW` - 記憶體載入字
- [ ] `SW` - 記憶體儲存字
- [ ] `BEQ` - 相等時分支
- [ ] `J` - 無條件跳躍
- [ ] `SYSCALL` - 系統調用

#### ✅ 系統調用功能驗證
- [ ] Print Integer (syscall 1)
- [ ] Print String (syscall 4) - **需要先在記憶體中準備字串數據**
- [ ] Read Integer (syscall 5)  
- [ ] Exit Program (syscall 10)

#### 📝 字串列印特別說明
在 MIPS 中列印字串需要兩個步驟：

1. **準備字串數據**: 將字串以 null-terminated 格式存入記憶體
```mips
# 存儲 "Hi!" 字串的範例
addi $t0, $zero, 0x48       # 'H' (ASCII 72)
addi $t1, $zero, 0x69       # 'i' (ASCII 105) 
addi $t2, $zero, 0x21       # '!' (ASCII 33)
sll $t1, $t1, 8            # 將 'i' 移到第二個位元組
sll $t2, $t2, 16           # 將 '!' 移到第三個位元組
add $t0, $t0, $t1          # 組合 H + i
add $t0, $t0, $t2          # 組合 H + i + !
sw $t0, 0x1000($zero)      # 儲存到記憶體位址 0x1000
```

2. **調用列印系統調用**:
```mips
addi $v0, $zero, 4      # syscall 4: print_string
addi $a0, $zero, 0x1000 # 字串位址
syscall                 # 執行列印
```

**記憶體中的字串格式**:
- 字串必須以 null 字元 (\0) 結尾
- 每個字元占用一個位元組
- MIPS 使用 little-endian 位元組順序

#### ✅ GUI 功能驗證
- [ ] 程式碼編輯器正常運作
- [ ] 寄存器即時更新顯示
- [ ] 記憶體內容正確顯示
- [ ] 控制台輸出正常
- [ ] Execute 按鈕功能
- [ ] Step 按鈕功能
- [ ] Reset 按鈕功能
- [ ] 載入示例程式功能

### 🎯 學習建議執行順序

1. **初學者**: 從 `gui_demo_test.asm` 開始
   - 理解基本指令執行流程
   - 熟悉 GUI 介面操作

2. **進階學習**: 使用 `demo_syscalls.asm`
   - 學習系統調用機制
   - 理解程式與系統的互動

3. **深度學習**: 分析 `test_control.asm`
   - 理解控制流程指令
   - 學習分支預測概念

4. **自主實作**: 參考其他測試檔案
   - 撰寫自己的 MIPS 程式
   - 使用除錯功能定位問題

## 🔧 進階功能與設定

### 效能監控
- **週期計數**：顯示執行總週期數
- **指令計數**：顯示執行指令數量
- **IPC (每週期指令數)**：管線效率指標
- **暫停週期**：資料相依性造成的延遲

### 除錯功能
- **中斷點設定**：在特定指令設定中斷點（未來功能）
- **單步回退**：回到上一個執行狀態（未來功能）
- **記憶體監視**：監視特定記憶體位址變化（未來功能）

### 匯出功能
- **執行追蹤**：匯出完整執行歷程（未來功能）
- **效能報告**：產生效能分析報告（未來功能）
- **狀態快照**：儲存當前模擬器狀態（未來功能）

## 📱 技術支援與社群

### 回報問題
如果遇到技術問題，請提供以下資訊：
- 作業系統版本
- 錯誤訊息截圖
- 重現問題的步驟
- 使用的 MIPS 程式碼

### 功能建議
歡迎提出改進建議：
- 新指令支援需求
- UI/UX 改善建議
- 教育功能增強提案
- 效能最佳化想法

---

**結語**：MIPS Assembly Simulator GUI 是一個強大的教育工具，透過視覺化介面讓 MIPS 彙編語言學習變得更加直觀和有趣。希望這個工具能夠幫助您更好地理解電腦架構和處理器設計的基本概念。

**版本資訊**：Dear ImGui Version 1.0 | 最後更新：2025-07-31
